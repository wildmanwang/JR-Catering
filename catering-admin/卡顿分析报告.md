# Dish.vue 窗口切换回来时的卡顿分析报告

## 卡顿产生的位置和原因

### 1. **页面显示阻塞（主要卡顿原因）**

**位置：** `BaseGrid.vue` 第 1931 行
```vue
<div class="base-grid-wrapper" v-show="pageReady">
```

**问题：**
- 页面内容被 `v-show="pageReady"` 隐藏，直到所有初始化完成才显示
- `pageReady` 在 `getList().then()` 中才设置为 `true`（第 1043 行）
- 用户看到的是空白页面，直到所有数据加载完成

**卡顿时长：** 取决于所有 API 请求的完成时间

---

### 2. **串行的 API 请求（次要卡顿原因）**

**位置：** `BaseGrid.vue` 的 `onMounted`（第 1004-1065 行）

**执行顺序：**
```javascript
onMounted(async () => {
  // 1. 初始化选项数据（并行，但需要等待完成）
  await initFieldOptions()  // API: getDishStatusOptionsApi
  
  // 2. 初始化快捷查询列表（串行）
  if (props.quickQueryList) {
    await initQuickQueryList()  // API: getKitchenListApi
    await nextTick()
    setMenuMaxHeight()
  }
  
  // 3. 等待状态恢复（串行）
  await nextTick()
  await nextTick()
  
  // 4. 获取表格数据（串行，必须等待前面的完成）
  getList().then(async () => {
    // 5. 恢复表格选择状态
    // 6. 设置 pageReady = true（此时页面才显示）
  })
})
```

**问题：**
- `initFieldOptions()` 和 `initQuickQueryList()` 虽然各自内部并行，但它们是串行执行的
- 必须等待所有选项数据加载完成后，才开始加载快捷查询列表
- 必须等待快捷查询列表加载完成后，才开始恢复状态
- 必须等待状态恢复完成后，才开始加载表格数据
- 必须等待表格数据加载完成后，页面才显示

**卡顿时长：** 
- initFieldOptions: ~100-300ms（取决于 API 响应时间）
- initQuickQueryList: ~100-300ms
- 状态恢复: ~50-100ms（多个 nextTick）
- getList: ~200-500ms（取决于数据量）

**总计：** ~450-1200ms（取决于网络和服务器响应）

---

### 3. **状态恢复中的多个 nextTick（轻微卡顿）**

**位置：** `BaseGrid.vue` 的 `setState`（第 1405-1468 行）

**执行顺序：**
```javascript
setState: async (state: any) => {
  // 1. 恢复查询条件
  if (state.formDisplayParams) {
    await nextTick()  // 等待 QueryBar 组件就绪
    await queryBarRef.value.setValues(state.formDisplayParams)  // DOM 操作
  }
  
  // 2. 恢复分页（多个 nextTick）
  if (state.pageSize !== undefined) {
    if (pageSizeChanged && targetCurrentPage !== 1) {
      currentPage.value = 1
      await nextTick()  // 第 1 个 nextTick
    }
    if (pageSizeChanged) {
      pageSize.value = targetPageSize
      await nextTick()  // 第 2 个 nextTick
    }
    if (currentPageChanged) {
      currentPage.value = targetCurrentPage
      await nextTick()  // 第 3 个 nextTick
    }
  }
  
  await nextTick()  // 第 4 个 nextTick
}
```

**问题：**
- 分页恢复使用了 3-4 个 `nextTick()`，每个 `nextTick()` 需要等待一个渲染周期
- 虽然单个 `nextTick()` 很快（~16ms），但累积起来也有 ~50-100ms

**卡顿时长：** ~50-100ms

---

### 4. **StatusStoragePlus 的状态恢复（轻微卡顿）**

**位置：** `StatusStoragePlus.vue` 的 `restorePageState`（第 309-386 行）

**执行顺序：**
```javascript
restorePageState: async () => {
  // 1. 读取 sessionStorage（同步，但可能较慢）
  const savedState = storage.value.getItem(PAGE_STATE_KEY.value)
  const statePayload = JSON.parse(savedState)  // JSON 解析（同步）
  
  // 2. 遍历所有 stores，串行恢复
  for (const store of props.stores) {
    if (store.componentRef) {
      await nextTick()  // 等待组件就绪
      if (!ref.value) {
        await nextTick()  // 再等待一次
      }
      await ref.value[methodName](params)  // 调用组件方法
    }
    await store.setState(stateData)  // 调用 setState（包含多个 nextTick）
  }
  
  await nextTick()  // 最后等待一次
}
```

**问题：**
- JSON 解析大量状态数据可能较慢（如果状态数据很大）
- 串行恢复每个 store，每个 store 的 setState 中又有多个 nextTick
- 组件方法调用（如 QueryBar.setValues）可能涉及 DOM 操作

**卡顿时长：** ~100-200ms（取决于状态数据大小和组件操作复杂度）

---

### 5. **图片字段处理（轻微卡顿）**

**位置：** `BaseGrid.vue` 的 `fetchDataApi`（第 1174-1185 行）

**执行顺序：**
```javascript
fetchDataApi: async () => {
  const res = await props.fetchDataApi({...})
  
  // 处理图片字段（同步操作，但可能较慢）
  const imageFields = props.columns
    .filter((col) => col.type === 'image')
    .map((col) => col.field)
  
  const processedData = dataList.map((row: any) => 
    processImageFields(row, imageFields, {...})  // 遍历所有行，处理图片
  )
}
```

**问题：**
- 如果数据量大（如 100+ 行），每行都要处理图片字段
- `processImageFields` 需要遍历行的所有字段，检查是否是图片字段
- 图片数组的排序和前缀移除操作

**卡顿时长：** ~10-50ms（取决于数据行数和图片数量）

---

## 卡顿时间汇总

| 操作 | 预估时间 | 是否阻塞页面显示 |
|------|---------|----------------|
| initFieldOptions | 100-300ms | 是 |
| initQuickQueryList | 100-300ms | 是 |
| 状态恢复（nextTick） | 50-100ms | 是 |
| restorePageState | 100-200ms | 是 |
| getList（API + 图片处理） | 200-500ms | 是 |
| 恢复表格选择 | 10-50ms | 是 |
| **总计** | **560-1450ms** | **是** |

---

## 卡顿的根本原因

1. **页面显示被完全阻塞**：`v-show="pageReady"` 导致用户看到空白页面，直到所有操作完成
2. **串行执行**：多个 API 请求和操作必须串行执行，无法并行优化
3. **过多的 nextTick**：状态恢复过程中使用了大量的 `nextTick()`，累积延迟
4. **同步阻塞操作**：JSON 解析、图片处理等同步操作在主线程执行

---

## 优化建议（暂不修改，仅记录）

### 1. **渐进式显示**
- 移除 `v-show="pageReady"`，改为显示加载状态
- 先显示页面框架，数据加载完成后填充内容

### 2. **并行优化**
- 将 `initFieldOptions()` 和 `initQuickQueryList()` 并行执行
- 状态恢复和数据加载可以并行进行

### 3. **减少 nextTick**
- 合并多个 `nextTick()` 调用
- 使用 `watchEffect` 或 `watch` 替代部分 `nextTick()`

### 4. **异步处理**
- 将图片处理移到 Web Worker 或使用 `requestIdleCallback`
- JSON 解析可以使用 `JSON.parse` 的异步版本（如果存在）

### 5. **缓存优化**
- 选项数据可以缓存，避免每次切换都重新加载
- 快捷查询列表数据可以缓存

---

## 额外的卡顿点（watch 监听器）

### 6. **watch 监听器可能触发的额外操作**

**位置：** `BaseGrid.vue` 第 1089-1100 行、1101-1118 行、1741-1755 行

**问题：**
- `watch(() => props.quickQueryList)` 可能触发 `setMenuMaxHeight()`
- `watch(() => quickQueryData.value)` 可能触发 `setMenuMaxHeight()`
- `watch(() => [currentPage.value, pageSize.value])` 可能触发 `getList()`

**卡顿时长：** 如果 watch 在状态恢复过程中触发，会增加额外的延迟

---

## 详细执行时间线（切换回来时）

```
时间轴：
0ms     - 组件开始挂载
        ↓
0-300ms - initFieldOptions() [API: getDishStatusOptionsApi]
        ↓
300-600ms - initQuickQueryList() [API: getKitchenListApi]
        ↓
600-650ms - nextTick() x2 + setMenuMaxHeight()
        ↓
650-850ms - StatusStoragePlus.restorePageState()
          - JSON.parse(savedState)
          - QueryBar.setValues() [DOM 操作]
          - 恢复分页（nextTick x3-4）
          - 恢复快捷查询选择
        ↓
850-1350ms - getList() [API: getDishListApi]
           - 处理图片字段（同步）
        ↓
1350-1400ms - 恢复表格选择状态
           ↓
1400ms - pageReady = true [页面显示]
```

**总卡顿时长：** ~1400ms（1.4秒）

---

## 总结

主要卡顿原因按影响程度排序：

1. **页面显示阻塞**（最重要）：`v-show="pageReady"` 导致用户看到空白页面
2. **串行 API 请求**：必须等待前一个完成才能开始下一个
3. **状态恢复的多个 nextTick**：累积延迟
4. **同步操作**：JSON 解析、图片处理在主线程执行
5. **DOM 操作**：QueryBar.setValues 等操作可能较慢

